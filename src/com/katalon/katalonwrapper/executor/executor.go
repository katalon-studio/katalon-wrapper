package executor

import (
	"com/katalon/katalonwrapper/utils"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

// Expects katPath to be the absolute path to Katalon Studio
// args should be the commands generated by Command Builder in Katalon Studio
func Execute(katPath string, args []string) {
	var (
		files               []string
		err                 error
		pathToRuntimeEngine string
	)
	// Find katalonc (run time engine) within the provided katPath
	files, err = filePathWalkDir(katPath)
	utils.HandleErrorIfExists(err, "Unable to find Katalon executable.\n")

	for _, file := range files {
		filePathSeparatedByDash := strings.Split(file, string(os.PathSeparator))
		_, _ = regexp.MatchString("p([a-z]+)ch", "peach")
		lastEle := filePathSeparatedByDash[len(filePathSeparatedByDash)-1]
		if isExecutable, _ := regexp.MatchString("^katalon(.exe)?$", lastEle); isExecutable {
			pathToRuntimeEngine = file
			log.Println("Path to runtime engine: ", file)
			break
		}
	}
	internallyMakeRuntimeEngineExecutable(pathToRuntimeEngine)
	internallyExecute(pathToRuntimeEngine, args)
}

func internallyMakeRuntimeEngineExecutable(pathToRuntimeEngine string) {
	err := os.Chmod(pathToRuntimeEngine, 0777)
	utils.HandleErrorIfExists(err, "")
}

func internallyExecute(katExecutable string, args []string) {
	log.Println("Katalon Executable:", katExecutable)
	for _, v := range args {
		log.Println("Katalon Argument:", v)
	}
	RunCMD(katExecutable, args)
}

func RunCMD(path string, args []string) {
	cmd := exec.Command(path, args...)
	mwriter := io.MultiWriter(os.Stdout)
	cmd.Stdout = mwriter
	cmd.Stderr = mwriter
	err := cmd.Run()
	utils.HandleErrorIfExists(err, "")
}

func filePathWalkDir(root string) ([]string, error) {
	var files []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if !info.IsDir() {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}
