package executor

import (
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// Expects katPath to be the absolute path to Katalon Studio
// args should be the commands generated by Command Builder in Katalon Studio
func Execute(katPath string, args []string) {
	var (
		files               []string
		err                 error
		pathToRuntimeEngine string
	)
	// Find katalonc (run time engine) within the provided katPath
	files, err = filePathWalkDir(katPath)
	if err != nil {
		panic(err)
	}

	for _, file := range files {
		filePathSeparatedByDash := strings.Split(file, string(os.PathSeparator))
		lastEle := filePathSeparatedByDash[len(filePathSeparatedByDash)-1]
		if lastEle == "katalon" {
			pathToRuntimeEngine = file
			fmt.Println("Path to runtime engine: ", file)
			break
		}
	}
	internallyMakeRuntimeEngineExecutable(pathToRuntimeEngine)
	internallyExecute(pathToRuntimeEngine, args)
}

func internallyMakeRuntimeEngineExecutable(pathToRuntimeEngine string) {
	err := os.Chmod(pathToRuntimeEngine, 0777)
	if err != nil {
		fmt.Println(err)
	}
}

func internallyExecute(katExecutable string, args []string) {
	fmt.Println("Katalon Executable: ", katExecutable)
	for _, v := range args {
		fmt.Println("Katalon Argument: ", v)
	}
	RunCMD(katExecutable, args)
}

func RunCMD(path string, args []string) {
	cmd := exec.Command(path, args...)
	mwriter := io.MultiWriter(os.Stdout)
	cmd.Stdout = mwriter
	cmd.Stderr = mwriter
	err := cmd.Run()
	if err != nil {
		panic(err)
	}
}

func filePathWalkDir(root string) ([]string, error) {
	var files []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if !info.IsDir() {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}
